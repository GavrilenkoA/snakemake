# Snakmake

Оу, всем привет. Сегодня мы расмотрим технологию Snakemake.

Подозреваю у каждого были моменты, когда вы последовательно обрабатывали данные, и вдруг поняли, что ошиблись с командой в самом начале анализа. И так как, каждый следующий шаг зависил от предыдущего, вам приходилось выполнять всю последовательность команд заново. Согласитесь неудобно? Подобную проблему решает snakemake (SNK),  позволяет создавать пайплайны из разных сниппетов кода, причем можно объединять любые скрипты (Bash, R, Python).

SNK преследует парадигму последовательного выполнения команд, пайплайн складывается в виде набора правил (rule) - как определить output файл из input файла. Зависимости между такими правилами определяются автоматически - создается направленный ациклический граф вычислений, которые могут быть параллелизованы.

Давайте установим SNK и попробуем сделать первую команду.

!pip install snakemake 

Сами команды SNK пишутся в отдельном файле Snakefile с указанием числа используемых ядер.

Напишем первую команду записи строки в файл.

![Untitled](Snakmake%20d6c68080c5cf46dea0079ee31d315f6a/Untitled.png)

 В этом примере создается текстовый файл с именем words.txt .

```bash
snakemake -s Snakefile --cores all
```

Давайте добавим команду для подсчета символов в строке.

![Untitled](Snakmake%20d6c68080c5cf46dea0079ee31d315f6a/Untitled%201.png)

SNK выполняет вычисления экономно, то есть если в директории уже есть один из промежуточных файлов, которые вы получаете во время выполнения пайплайна SNK процесс вычислений не запустится. Для игнорирования этого, стоит добавить флаг -f или удалить все файлы полученные до этого.

Покольку файл 'words.txt' уже есть:

```bash
snakemake -s Snakefile -f --cores all
```

Принципиально важен порядок команд. Поскольку выполняется фактически стек вызовов, первая команда, прописанная в пайплайне, будет выполняться последней.

![Untitled](Snakmake%20d6c68080c5cf46dea0079ee31d315f6a/Untitled%202.png)

**Использование Python скриптов в Snakemake.**

Представим задачу - допустим есть файл со строкой, нужно посчитать кол-во уникальных элементов в строке и записать в отдельный файл. Для этого помогут пара функций на Python.

![Untitled](Snakmake%20d6c68080c5cf46dea0079ee31d315f6a/Untitled%203.png)

```bash
snakemake -s snakefile.smk --cores 1
```

Python скрипты запускаются с помощью метода run.

Ок, а что если таких файлов не один, а много?. В этом помогут wildcards.

**Wildcards** полезны, когда у вас есть набор связанных файлов, которые следуют шаблону имени и вы хотите выполнить одно и то же правило для всех них.  Вы можете написать одно правило, которое применяется к нескольким файлам, без явного перечисления каждого файла.

Пусть в директории `input_files` лежат файлы, и мы хотим над каждым сделать операцию подсчета уникальных символов. 

Все тоже самое, как в предыдщем примере, теперь нужна заготовка с перечислением всех файлов идущих программе на вход.

![Untitled](Snakmake%20d6c68080c5cf46dea0079ee31d315f6a/Untitled%204.png)

Правило all как бы собирает результат всех вычислений, которые мы получили в правиле process_rule. 

Иной способ, как можно склеить все input файлы - это метод expand 

![Untitled](Snakmake%20d6c68080c5cf46dea0079ee31d315f6a/Untitled%205.png)

Да, поскольку SNK параллелит исполнение команд, можно  задавать число ядер как для исполнения всего пайплайна.

Что интересно, у меня не исполняется snakefile если не указывать число ядер на исполение. 

```bash
snakemake -s snakefile.smk
```

*Error: you need to specify the maximum number of CPU cores to be used at the same time. If you want to use N cores, say --cores N or -cN. For all cores on your system (be sure that this is appropriate) use --cores all.* 

Также возможно  задавать число потоков на одно правило.

```bash
rule NAME:
    input: "path/to/inputfile"
    output: "path/to/outputfile"
    threads: 8
    shell: "somecommand --threads {threads} {input} {output}"
```

Давайте решим задачу выравнивания коротких прочтений  на референс с помощью  snakemake.
